package models

import (
	"encoding/json"
	"fmt"
	"net/url"
	"strconv"
	"strings"
	"time"

	"github.com/beego/beego/v2/client/httplib"
)

type Asset struct {
	Nickname string
	Bean     struct {
		Total       int
		TodayIn     int
		TodayOut    int
		YestodayIn  int
		YestodayOut int
		ToExpire    []int
	}
	RedPacket struct {
		Total      float64
		ToExpire   float64
		ToExpireJd float64
		ToExpireJx float64
		ToExpireJs float64
		ToExpireJk float64
		Jd         float64
		Jx         float64
		Js         float64
		Jk         float64
	}
}

var Int = func(s string) int {
	i, _ := strconv.Atoi(s)
	return i
}

var Float64 = func(s string) float64 {
	i, _ := strconv.ParseFloat(s, 64)
	return i
}

func DailyAssetsPush() {
	for _, ck := range GetJdCookies() {
		if (ck.QQ != 0 && Config.QQID != 0 && SendQQ != nil) || ck.PushPlus != "" {
			msg := ""
			for _, task := range Config.Tasks {
				if task.Word == "æŸ¥è¯¢" {
					task.Envs = []Env{{
						Name:  "pins",
						Value: ck.PtPin,
					}}
					task.Ykq = false
					msg = runTask(&task)
					break
				}
			}
			if ck.QQ != 0 && Config.QQID != 0 && SendQQ != nil {
				SendQQ(int64(ck.QQ), msg)
			}
			if ck.PushPlus != "" {
				pushPlus(ck.PushPlus, msg)
			}
		}
	}
}

func (ck *JdCookie) Query() string {
	msgs := []string{
		fmt.Sprintf("è´¦å·æ˜µç§°ï¼š%s", ck.Nickname),
	}
	asset := Asset{}
	if CookieOK(ck) {
		cookie := fmt.Sprintf("pt_key=%s;pt_pin=%s;", ck.PtKey, ck.PtPin)
		var rpc = make(chan []RedList)
		go redPacket(cookie, rpc)
		today := time.Now().Local().Format("2006-01-02")
		yestoday := time.Now().Local().Add(-time.Hour * 24).Format("2006-01-02")
		page := 1
		end := false
		for {
			if end {
				break
			}
			bds := getJingBeanBalanceDetail(page, cookie)
			if bds == nil {
				end = true
				msgs = append(msgs, "äº¬è±†æ•°æ®å¼‚å¸¸")
				break
			}
			for _, bd := range bds {
				amount := Int(bd.Amount)
				if strings.Contains(bd.Date, today) {
					if amount > 0 {
						asset.Bean.TodayIn += amount
					} else {
						asset.Bean.TodayOut += -amount
					}
				} else if strings.Contains(bd.Date, yestoday) {
					if amount > 0 {
						asset.Bean.YestodayIn += amount
					} else {
						asset.Bean.YestodayOut += -amount
					}
				} else {
					end = true
					break
				}
			}
			page++
		}
		msgs = append(msgs, []string{
			fmt.Sprintf("æ˜¨æ—¥æ”¶å…¥ï¼š%däº¬è±†", asset.Bean.YestodayIn),
			fmt.Sprintf("æ˜¨æ—¥æ”¯å‡ºï¼š%däº¬è±†", asset.Bean.YestodayOut),
			fmt.Sprintf("ä»Šæ—¥æ”¶å…¥ï¼š%däº¬è±†", asset.Bean.TodayIn),
			fmt.Sprintf("ä»Šæ—¥æ”¯å‡ºï¼š%däº¬è±†", asset.Bean.TodayOut),
		}...)
		msgs = append(msgs, fmt.Sprintf("å½“å‰äº¬è±†ï¼š%väº¬è±†", ck.BeanNum))
		ysd := int(time.Now().Add(24 * time.Hour).Unix())
		if rps := <-rpc; len(rps) != 0 {
			for _, rp := range rps {
				b := Float64(rp.Balance)
				asset.RedPacket.Total += b
				if strings.Contains(rp.ActivityName, "äº¬å–œ") {
					asset.RedPacket.Jx += b
					if ysd >= rp.BeginTime {
						asset.RedPacket.ToExpireJx += b
						asset.RedPacket.ToExpire += b
					}
				} else if strings.Contains(rp.ActivityName, "æé€Ÿç‰ˆ") {
					asset.RedPacket.Js += b
					if ysd >= rp.BeginTime {
						asset.RedPacket.ToExpireJs += b
						asset.RedPacket.ToExpire += b
					}

				} else if strings.Contains(rp.ActivityName, "äº¬ä¸œå¥åº·") {
					asset.RedPacket.Jk += b
					if ysd >= rp.BeginTime {
						asset.RedPacket.ToExpireJk += b
						asset.RedPacket.ToExpire += b
					}
				} else {
					asset.RedPacket.Jd += b
					if ysd >= rp.BeginTime {
						asset.RedPacket.ToExpireJd += b
						asset.RedPacket.ToExpire += b
					}
				}
			}
			msgs = append(msgs, []string{
				fmt.Sprintf("æ‰€æœ‰çº¢åŒ…ï¼š%.2f(ä»Šæ—¥æ€»è¿‡æœŸ%.2f)å…ƒğŸ§§", asset.RedPacket.Total, asset.RedPacket.ToExpire),
				fmt.Sprintf("äº¬å–œçº¢åŒ…ï¼š%.2f(ä»Šæ—¥æ€»è¿‡æœŸ%.2f)å…ƒğŸ§§", asset.RedPacket.Jx, asset.RedPacket.ToExpireJx),
				fmt.Sprintf("æé€Ÿçº¢åŒ…ï¼š%.2f(ä»Šæ—¥æ€»è¿‡æœŸ%.2f)å…ƒğŸ§§", asset.RedPacket.Js, asset.RedPacket.ToExpireJs),
				fmt.Sprintf("å¥åº·çº¢åŒ…ï¼š%.2f(ä»Šæ—¥æ€»è¿‡æœŸ%.2f)å…ƒğŸ§§", asset.RedPacket.Jk, asset.RedPacket.ToExpireJk),
				fmt.Sprintf("äº¬ä¸œçº¢åŒ…ï¼š%.2f(ä»Šæ—¥æ€»è¿‡æœŸ%.2f)å…ƒğŸ§§", asset.RedPacket.Jd, asset.RedPacket.ToExpireJd),
			}...)
		} else {
			msgs = append(msgs, "æš‚æ— çº¢åŒ…æ•°æ®ğŸ§§")
		}
	} else {
		msgs = append(msgs, []string{
			"æé†’ï¼šè¯¥è´¦å·å·²è¿‡æœŸï¼Œè¯·é‡æ–°ç™»å½•",
		}...)
	}
	ck.PtPin, _ = url.QueryUnescape(ck.PtPin)
	return strings.Join(msgs, "\n")
}

type BeanDetail struct {
	Date         string `json:"date"`
	Amount       string `json:"amount"`
	EventMassage string `json:"eventMassage"`
}

func getJingBeanBalanceDetail(page int, cookie string) []BeanDetail {
	type AutoGenerated struct {
		Code       string       `json:"code"`
		DetailList []BeanDetail `json:"detailList"`
	}
	a := AutoGenerated{}
	req := httplib.Post(`https://api.m.jd.com/client.action?functionId=getJingBeanBalanceDetail`)
	req.Header("User-Agent", ua)
	req.Header("Host", "api.m.jd.com")
	req.Header("Content-Type", "application/x-www-form-urlencoded")
	req.Header("Cookie", cookie)
	req.Body(fmt.Sprintf(`body={"pageSize": "20", "page": "%d"}&appid=ld`, page))
	data, err := req.Bytes()
	if err != nil {
		return nil
	}
	json.Unmarshal(data, &a)
	return a.DetailList
}

type RedList struct {
	ActivityName string `json:"activityName"`
	Balance      string `json:"balance"`
	BeginTime    int    `json:"beginTime"`
	DelayRemark  string `json:"delayRemark"`
	Discount     string `json:"discount"`
	EndTime      int    `json:"endTime"`
	HbID         string `json:"hbId"`
	HbState      int    `json:"hbState"`
	IsDelay      bool   `json:"isDelay"`
	OrgLimitStr  string `json:"orgLimitStr"`
}

func redPacket(cookie string, rpc chan []RedList) {
	type UseRedInfo struct {
		Count   int       `json:"count"`
		RedList []RedList `json:"redList"`
	}
	type Data struct {
		AvaiCount      int        `json:"avaiCount"`
		Balance        string     `json:"balance"`
		CountdownTime  string     `json:"countdownTime"`
		ExpiredBalance string     `json:"expiredBalance"`
		ServerCurrTime int        `json:"serverCurrTime"`
		UseRedInfo     UseRedInfo `json:"useRedInfo"`
	}
	type AutoGenerated struct {
		Data    Data   `json:"data"`
		Errcode int    `json:"errcode"`
		Msg     string `json:"msg"`
	}
	a := AutoGenerated{}
	req := httplib.Get(`https://m.jingxi.com/user/info/QueryUserRedEnvelopesV2?type=1&orgFlag=JD_PinGou_New&page=1&cashRedType=1&redBalanceFlag=1&channel=1&_=` + fmt.Sprint(time.Now().Unix()) + `&sceneval=2&g_login_type=1&g_ty=ls`)
	req.Header("User-Agent", ua)
	req.Header("Host", "m.jingxi.com")
	req.Header("Accept", "*/*")
	req.Header("Connection", "keep-alive")
	req.Header("Accept-Language", "zh-cn")
	req.Header("Accept-Encoding", "gzip, deflate, br")
	req.Header("Referer", "https://st.jingxi.com/my/redpacket.shtml?newPg=App&jxsid=16156262265849285961")
	req.Header("Cookie", cookie)
	data, _ := req.Bytes()
	json.Unmarshal(data, &a)
	rpc <- a.Data.UseRedInfo.RedList
}
